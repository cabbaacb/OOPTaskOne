# OOPTaskOne
our try to complete the first OOP task.

Задание:
Разработать часть игровой логики, связанную с противниками и снарядами в игровом мире.

Обязательные требования:

Создать сущности EnemyData и ProjectileData, который:

EnemyData, содержит информацию для настройки компонента противников и содержит следующую информацию: тип противника, здоровье, тип используемого снаряда, скорость атаки, дальность атаки и скорость перемещения;
ProjectileData, содержит информацию для настройки компонента снаряда и содержит следующую информацию: тип снаряда, урон, скорость перемещения и время жизни снарядов.
Создать компоненты игрока и противника, которые отслеживают готовность выстрела и стреляют, когда это возможно:

У игрока стрельба происходит по нажатию на соответствующую кнопку;
У противников стрельба происходит, если игрок находится на расстоянии атаки (настраивается в EnemyData).
Создать управляющий компонент, который следит за временем жизни всех снарядов и за здоровьем противников, если эти значения отрицательные или равны нулю - уничтожает их.

Ограничения

Управляющий компонент должен содержать пул всех противников и снарядов. У компонента должны быть реализованы методы создания новых снарядов и противников, а сами противники и игрок не должны создавать снаряды самостоятельно.
У снарядов и противников не должно быть методов Update(), LateUpdate(), FixedUpdate() и корутин - логика стрельбы и перемещения необходимо реализовать в управляющем компоненте. В задании можно пренебречь перемещением противников и не реализовывать эту логику (только стрельбу).
В коде должны использоваться минимум одно перечисление и одна структура.
Дополнительные требования

Добавить ограничение на коллизии снарядов. Если снаряд выпустил игрок - он не должен получать от него урона, аналогично со снарядами противников.
Реализовать у игрока возможность использовать несколько видов оружия и переключаться между ними.
При попадании снарядов в игрока или в противника, они должны терять здоровье (например, у противников здоровье настраивается в EnemyData), снаряды при коллизии должны уничтожаться через управляющий компонент.
Подсказки

Настраивать игру в редакторе нет необходимости, достаточно написать сам код.
Если нужно связать несвязанные объекты, можно прибегнуть к ключевому слову static, тогда к полю/методу/классу можно будет обращаться из любого места в коде.
Если не хочется применять static, можно при создании игровых объектов передавать им ссылки на компоненты, с которыми они буду взаимодействовать.
В данном задании, можно пренебречь тем, что снаряды и противники должны отличаться визуально, предположим, что их отличие заключается только в разных данных.
Чтобы поля класса или структуры отображались в инспекторе, ее нужно пометить атрибутом [Serializable], как указано ниже. Таким образом, компоненты с ссылками на данные классы/структуры, будут отображать их поля в инспекторе:
[Serializable]
1
2
3
4
public struct HealthBar
{
public float Heath;
}
Когда в игре существует несколько разновидностей однотипных сущностей, удобно отслеживать принадлежность к виду через перечисление.*
